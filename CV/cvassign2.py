# -*- coding: utf-8 -*-
"""CVassign2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_209P_Hw-Zs8K-E5WzdTSxnROiI8s1br

#COMPUTER VISION ASSIGNMENT 2


**Srijit Saha**


*MDS202150*

**Q7)**
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = (15, 12)

img1 = cv2.imread('image1.jpg')
img2 = cv2.imread('image2.jpg')
img3 = cv2.imread('image3.jpg')
fig, ax = plt.subplots(1,2)
ax[0].imshow(cv2.cvtColor(img1, cv2.COLOR_BGR2RGB))
ax[0].set_title('Image 1')
ax[1].imshow(cv2.cvtColor(img2, cv2.COLOR_BGR2RGB))
ax[1].set_title('Image 2');

pts1 = np.array([[814, 1236], [1696, 2819],  [3751, 1485], [2728, 127]])
pts2 = np.array([[1396, 594], [1420, 2185],  [3688, 2090], [3488, 481]])

def calcA(pts1, pts2, n_p=4):
    A = []

    for i in range(0, n_p):
        x, y = pts1[i, 0], pts1[i, 1]
        x1, y1 = pts2[i, 0], pts2[i, 1]

        A.append([0, 0, 0, -x, -y, -1, y1*x, y1*y, y1])
        A.append([x, y, 1, 0, 0, 0, -x1*x, -x1*y, -x1])

    # assert (np.shape(A) == (2*n_p, 9))
    return np.asarray(A)

def homography(pts1, pts2):

  # dimension 2n*9
  A = calcA(pts1, pts2)
  U, S, V = np.linalg.svd(A)
  # h is the last column of V
  h = V[-1, :]
  H = h.reshape(3,3)

  return H

H = homography(pts1, pts2)
print('Homography between image1 and image2:')
print(H)

A = calcA(pts1, pts2)
print("The matrix A representing the system of equations: ", sep = '\n')
print()
print(A)

print("Rank of A: ", np.linalg.matrix_rank(A))

h= cv2.findHomography(pts1, pts2)[0]
print('Homography between image1 and image2 (calculated using OpenCV):')
print(h)

h_new = h/np.linalg.norm(h)
print('Normalized h:', h_new, sep='\n')
print('\n\nThus our results are comparable to that from opencv')

# Warping image1
out = cv2.warpPerspective(img1, H ,(img2.shape[1], img2.shape[0]))
fig, ax = plt.subplots(1,2)
ax[0].imshow(cv2.cvtColor(out, cv2.COLOR_BGR2RGB))
ax[0].set_title('Warped Image 1')
ax[1].imshow(cv2.cvtColor(img2, cv2.COLOR_BGR2RGB))
ax[1].set_title('Image 2');

"""**The four points chosen from the source image, gets mapped on their corresponding points on the destination image. All points from the image situated on the same plane undergo the same transformation. On selecting a set of four points from the source image (image1), the plane on which these points reside in the real world gets aligned as the plane containing their four corresponding points in the destination image (image2).**


**Thus, *all* points on that plane get aligned correctly as they are in the destination image. But the points that are *not* on that plane will *not* be aligned by the homography, leaving the rest of the image covered by blank black pixels.**

**Q8)**
"""

# top-left, bottom-left, bottom-right, top-right

# Corner points of the book on source image
pts1 = np.array([[834, 1236], [1696, 2819],  [3751, 1485], [2728, 127]])

# Keeping aspect ratio as 30/23, the image size can be taken as 3000x2300
output_pts = np.array([[0,0], [0,2299], [2999,2299], [2999,0]])

# Calculating homography
H_new = homography(pts1, output_pts)
# Warping image
out = cv2.warpPerspective(img1, H_new ,(3000, 2300),flags=cv2.INTER_LINEAR)

fig, ax = plt.subplots(1,2)
ax[0].imshow(cv2.cvtColor(out, cv2.COLOR_BGR2RGB))
ax[0].set_title('Straightened Image 1')
ax[1].imshow(cv2.cvtColor(img3, cv2.COLOR_BGR2RGB))
ax[1].set_title('Image 3');

"""**Q9)**
#Applications of Homography:
**Perspective Warping**


*In perspective warping, we take a picture which is taken from a certain angle or perspective, and aim to straighten that image using homography to calculate the correct alignment.*


*The resulting image has a perspective such that the camera lens was parallel while clicking the object in the image*
*These are widely used today in applications such as Camscanner and the like.*
"""

img1 = cv2.imread('elonmusk.jpeg')
# Top left, bottom left, bottom right, top right corners of the paper
pts1 = np.array([[330, 410], [120, 1120], [1090, 1155], [890, 380]])

# Keeping the aspect ratio as 1: sqrt(2), the image size can be taken as 1415 x 1000
out_pts =  np.array([[0,0], [0,1414], [999,1414], [999,0]])

# Calculating homography
H_new = homography(pts1, out_pts)

# Warping image
out = cv2.warpPerspective(img1, H_new ,(999, 1414), flags=cv2.INTER_LINEAR)

fig, ax = plt.subplots(1,2)
ax[0].imshow(cv2.cvtColor(img1, cv2.COLOR_BGR2RGB))
ax[0].set_title('Original Book Cover')
ax[1].imshow(cv2.cvtColor(out, cv2.COLOR_BGR2RGB))
ax[1].set_title('Corrected Book Cover')
fig.savefig('Homography_correction.jpg')

"""**Replacing part of an image with another image using Homography.**

*Taking the corner pts of the cropped sub-images which are to be replaced, we calculate homography to calculate the perspective shift of the replacing image.*


*Using cv2, we place the image on the portion which was to be replaced in the original image, and thus obtain a digitally transformed picture, which we get in software platforms such as Photoshop.*

"""

fakead = cv2.imread("spotfyads.jpg")
billboard = cv2.imread("billboard.jpeg")
billb = billboard.copy()
fig, ax = plt.subplots(1,2)
ax[0].imshow((cv2.cvtColor(billboard, cv2.COLOR_BGR2RGB)))
ax[0].set_title('Original Billboard')
ax[1].imshow(cv2.cvtColor(fakead, cv2.COLOR_BGR2RGB))
ax[1].set_title('Replacement Advertisement')

pts_dst = np.array([[495,360],[496,473],[725,468],[723,358]])
pts_src = np.array([[0,1],[1,262],[627,266],[625, 3]])
Hg = homography(pts_src, pts_dst)
result = cv2.warpPerspective(fakead, Hg, (billboard.shape[1], billboard.shape[0]), flags=cv2.INTER_LINEAR)

# plt.imshow(cv2.cvtColor(result, cv2.COLOR_BGR2RGB))
cv2.fillConvexPoly(billboard, pts_dst.astype(int), 0, 16);
out1 = billboard + result
fig, ax = plt.subplots(1,2)
ax[0].imshow(cv2.cvtColor(billb, cv2.COLOR_BGR2RGB))
ax[0].set_title('Original Billboard')
ax[1].imshow(cv2.cvtColor(out1, cv2.COLOR_BGR2RGB))
ax[1].set_title('Fake billboard')
fig.savefig('Fake_billboard.jpg')