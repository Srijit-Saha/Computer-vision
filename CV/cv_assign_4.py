# -*- coding: utf-8 -*-
"""cv_assign_4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aaoTSNK0q_zp_CESubkJXhGysMZtpgAH

## Srijit Saha
**MDS202150**
"""

import cv2
import numpy as np
from skimage import data
from tqdm.auto import tqdm
import matplotlib.pyplot as plt
from google.colab import files as FILE
import os, requests
import urllib.request
plt.rcParams['figure.figsize'] = (12, 8)

!rm *.jpg *.png
!gdown 1iLrsnsZnYfzvDTQtCptBJkdJhgzGQVsz
!unzip histogram_assignment.zip

"""**1. Write a program to implement histogram equalization on an image. Write and implement a code that \\
(a) displays the histogram of the input image, \\
(b) implements histogram equalization as discussed in class, \\
(c) displays the equalized histogram, \\
(d) plots the transform function corresponding to the pair of input.**
"""

def image_and_hist(img, title):
  fig, ax = plt.subplots(1,2)
  ax[0].imshow(img, cmap = 'gray')
  ax[0].set_xticks([])
  ax[0].set_yticks([])
  ax[1].hist(img.flatten(),256,[0,256], color = 'r')
  fig.suptitle(title, fontsize=18)
  plt.show()

def intensity_hist(cdf):
  plt.plot(list(range(0,256)),cdf[list(range(0,256))])
  plt.xlabel("Input intensities", fontsize=12)
  plt.ylabel("Output intensities", fontsize=12)
  plt.title("\n\nIntensity transformation due to equalization", fontsize=18)
  plt.show()

def disp_subplots(image, shape, titles, sup_title, axes, figsize, cmap=None):
  fig, ax = plt.subplots(shape[0], shape[1], figsize=figsize)
  try:
    ax = ax.ravel()
  except:
    pass

  for i in range(shape[0]*shape[1]):
    if cmap is None:
      ax[i].imshow(image[i])
    else:
      ax[i].imshow(image[i], cmap=cmap)

    if axes[i] is None:
      ax[i].set_xticks([])
      ax[i].set_yticks([])

    if titles[i] is not None:
      ax[i].set_title(titles[i])

  if sup_title is not None:
    fig.suptitle(sup_title, fontsize=18)
  plt.show()

def histogram_equalization(image,readim = True, disp_graph=True, ret_image=False):
  # Reading image as grayscale
  if readim:
    image = cv2.imread(image,0)

  #flattening image array and calculating histogram
  hist, bins = np.histogram(image.flatten(),256,[0,256])
  cdf = hist.cumsum()

  cdf_m = np.ma.masked_equal(cdf,0)
  cdf_m = (cdf_m - cdf_m.min())*255/(cdf_m.max()-cdf_m.min())
  cdf = np.ma.filled(cdf_m,0).astype('uint8')

  if disp_graph:

    image_and_hist(image, 'Original Image')
    image_and_hist(cdf[image], 'Histogram Equalized Image')

    intensity_hist(cdf)
  if ret_image:
    return cdf[image]

histogram_equalization('einstein.jpg')

histogram_equalization('crayons.jpg')

"""**2. Use the above code to apply histogram equalization on the images uploaded in the Google folder labeled
‘Histogram assignment’. \\
(a) Compare your results with OpenCV’s cv2.equalizeHist() to see if you get comparable results. \\
(b) Is the intensity distribution of the equalized histogram a uniform distribution? Why or why not?**
"""

image = "image2.jpg"
img = cv2.imread(image,0)
hist, _ = np.histogram(img.flatten(),256,[0,256])
cdf = hist.cumsum()
eq_image = cv2.equalizeHist(img)
disp_subplots([cdf[img], eq_image], (1,2), ['Image obtained from manual implementation',
                                            'Image obtained using CV2'], '\n\nResult Comparison',[None, None],(12,8),'gray')

plt.hist(eq_image.flatten(),256,[0,256], color = 'green')
plt.title("Histogram for the CV2 equalised image")

"""**We could force all pixel values to have a certain distribution, but in that case we have no guarantee that it will correspond in some form to the original image. This why you might not see a properly uniform distribution after equalization. Histogram equalization will try to make the PDF as uniform as possible, while at the same time respecting the original properties of the image.**

**3. Download the image ‘image1’ and ‘image2’ from the Google folder \\
(a) Extract the 3 color channels for each image and plot their respective histograms (so six in all). \\
(b) For each channel, match the histograms of each colour channel of image1 with corresponding channel
histograms of image2. \\
(c) Reconstruct the new image1 in colour.  
(d) Compare the result with the original images.**
"""

def plot_hist_3chan(img):
  # Reading image
  image = cv2.imread(img)
  # Extracting channels
  channels = cv2.split(image)
  color = ['b', 'g', 'r']
  # Generating histograms
  fig, ax = plt.subplots(1,3, figsize=(15,5))
  for i in range(3):
    ax[i].hist(channels[i].flatten(), color=color[i])
    ax[i].set_title(f'Channel-{color[i]} Histogram')
  plt.suptitle(f"Histograms For {img.split('.')[0]}\n\n", fontsize=18)
  plt.show()

plot_hist_3chan("image1.jpg")

plot_hist_3chan("image2.jpg")

def find_nearest_above(src, target):
    diff = src - target
    mask = np.ma.less_equal(diff, -1)
    if np.all(mask):
      return np.abs(diff).argmin()
    masked_diff = np.ma.masked_array(diff, mask)
    return masked_diff.argmin()

def match_hist(src, dst):
    oldshape = src.shape
    src = src.ravel()
    dst = dst.ravel()

    '''
    get the set of unique pixel values and their
     corresponding indices and counts
    '''
    s_values, bin_idx, s_counts = np.unique(src,
                            return_inverse=True,return_counts=True)
    t_values, t_counts = np.unique(dst, return_counts=True)

    # Calculate s_k for original image
    s_quantiles = np.cumsum(s_counts).astype(np.float64)
    s_quantiles /= s_quantiles[-1]
        # Calculate s_k for specified image
    t_quantiles = np.cumsum(t_counts).astype(np.float64)
    t_quantiles /= t_quantiles[-1]

    # Round the values
    sour = np.around(s_quantiles*255)
    temp = np.around(t_quantiles*255)

    # Map the rounded values
    b=[]
    for data in sour[:]:
        b.append(find_nearest_above(temp,data))
    b= np.array(b,dtype='uint8')

    return b[bin_idx].reshape(oldshape)

def histogram_matching(img1, img2):
  # Reading images
  img1 = cv2.imread(img1)
  img2 = cv2.imread(img2)

  # Splitting channels from both images
  b_src, g_src, r_src = cv2.split(img1)
  b_dst, g_dst, r_dst = cv2.split(img2)

  # Applying histogram matching to all pairs
  b_new = match_hist(b_src,b_dst)
  g_new = match_hist(g_src,g_dst)
  r_new = match_hist(r_src,r_dst)

  # Merging new channels
  new_img = cv2.merge([b_new,g_new,r_new])

  # Plotting images
  disp_subplots([cv2.cvtColor(img1, cv2.COLOR_BGR2RGB),
                 cv2.cvtColor(img2, cv2.COLOR_BGR2RGB),
                 cv2.cvtColor(new_img, cv2.COLOR_BGR2RGB)],
                 (1,3), ['image1','image2','reconstructed image1'],
                 'Histogram Matching', [None,None,None], (15,5) ,None)

histogram_matching('image1.jpg','image2.jpg')

"""**5. Pick a grayscale image, either from the given ones or from scikit’s image repository. Perform intensity slicing
on the image in two ways: \\
(a) highlight a particular range and set the rest to zero; \\
(b) highlight a particular range and leave the rest unchanged. \\
In each case, plot the intensity transformation being applied. Display all results for comparison.**
"""

def intensity_slicing_0(img, min_range, max_range):
  row, column = img.shape
  # Creating an array with zeroes to store the sliced image
  img1 = np.zeros((row,column),dtype = 'uint8')

  #performing intensity slicing as asked in part (a)
  for i in range(row):
    for j in range(column):
      if img[i,j]>min_range and img[i,j] < max_range:
         img1[i,j] = 255
      else:
         img1[i,j] = 0
  return img1

def intensity_slicing_const(img, min_range, max_range):
  row, column = img.shape
  # Creating an array with zeroes to store the sliced image
  img1 = np.zeros((row,column),dtype = 'uint8')

  #performing intensity slicing as asked in part (a)
  for i in range(row):
    for j in range(column):
      if img[i,j]>min_range and img[i,j] < max_range:
        img1[i,j] = 255
      else:
         img1[i,j] = img[i-1,j-1]
  return img1

img = cv2.imread('chestxray1.png',0)

# Specify the min and max range
min_range = 10
max_range = 60

# Applying intensity slicing
images = [img, intensity_slicing_0(img, min_range, max_range),
          intensity_slicing_const(img, min_range, max_range)]

# Displaying results
disp_subplots(images, (1,3), ["Original image",
                              "Highlighting a particular range and setting the rest to zero",
                              "Highlighting a particular range keeping the rest unchanged"],
              "Comparing results from part a and part b\n",
              [None]*3, (20,5), cmap='gray')

"""**5. Pick a grayscale image, either from the given ones or from scikit’s image repository. Perform intensity slicing on the image in two ways: \\
(a) highlight a particular range and set the rest to zero. \\
(b) highlight a particular range and leave the rest unchanged. \\
In each case, plot the intensity transformation being applied. Display all results for comparison.**
"""

img = cv2.imread('chestxray1.png',0)
lst = []
for i in range(img.shape[0]):
  for j in range(img.shape[1]):
    # Here width = number of bits
    lst.append(np.binary_repr(img[i][j], width=8))

images = np.zeros((8, img.shape[0],img.shape[1]), np.uint8)

for j in range(0,8):
    b = 2**j
    images[j] = (np.array([int(i[7-j]) for i in lst],dtype = np.uint8)*b).reshape(img.shape[0],img.shape[1])

titles, imgs = [], []
for i in range(8):
  imgs.append(images[i]/np.max(images[i])*255)
  titles.append(f'Bitplane {i}')

# Displaying 8 bitplanes
disp_subplots(imgs, (2,4), titles, "Bitplanes\n",
              [None]*8, (20,8), cmap='gray')

# part b)
bitimg = []
bitimg.append(imgs[0])
bitimg.append(imgs[3])
bitimg.append(imgs[7])
for image in bitimg:
  hist,_ = np.histogram(image.flatten(),256,[0,256])
  cdf = hist.cumsum()
  intensity_hist(cdf)
hist,_ = np.histogram(new_img.flatten(),256,[0,256])
cdf = hist.cumsum()
intensity_hist(cdf)

# part c)
new_img = images[7]+images[6]+images[5] + images[4]
# Comparing results
disp_subplots([img, new_img], (1,2), ['Original Image',
              'Reconstructed image with 4 bitplanes:- 7, 6, 5, 4'], "Result Comparison\n",
              [None]*2, (10,5), cmap='gray')

new_img1 = images[7]+images[6]+images[5]
# Comparing results
disp_subplots([img, new_img1], (1,2), ['Original Image',
              'Reconstructed image with 3 bitplanes:- 7, 6, 5'], "Result Comparison\n",
              [None]*2, (10,5), cmap='gray')

"""### We can use 4 bitplanes in descending order and use the bitplane addition image as a reconstruction. Adding 4 bitplanes doesnt degrade the quality too much.
### However using 3 bitplanes is bringing a significant quality downgrade
"""