# -*- coding: utf-8 -*-
"""assign_CV12023.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OMUvim17mJA80GNRiDe29paQ00CUBglP

#Computer Vision Assignment 1

*Question 1 :*

Download the image *CinqueTerre.jpg* from the class folder. Read it using OpenCV and perform the following
operations.


(a) Find and store the size and number of channels of the image.


(b) For many computer vision and image processing tasks, you should be comfortable with accessing sub-regions of an image. Your task is to extract 50 by 50 image sub-regions from the top-left as well as the bottom right and store them in the variables subimg1 and subimg2 respectively.

After you successfully
extract subimg1 and subimg2 images,

compute the SSD (Sum of Squared Differences) of the intensities
between them and store in the variable SSD.
"""

import cv2 as cv
import numpy as np
from google.colab.patches import cv2_imshow
img = cv.imread('CinqueTerre.jpg')
#loading the image from specified directory
imgsize = img.shape
print(f'''Height of image: {imgsize[0]}
Width of image: {imgsize[1]}
No. of channels of image: {imgsize[2]}
''')
subimg1=img[0:50,0:50]
#Top-Left portion of the images
subimg2 = img[265:315,424:474]
#Bottom-right portion of the images


def ssd(i1,i2):
    return np.sum((np.array(i1, dtype=float) - np.array(i2, dtype=float))**2)
SSD = ssd(subimg1,subimg2)
print("The SSD betweeen the sub-images is: ",SSD)

"""*Question 2 :*

*Sergei Mikhailovich Prokudin-Gorskii (1863-1944) was a man well ahead of his time. Convinced, as early as
1907, that color photography was the wave of the future, he won Tzar's special permission to travel across the
vast Russian Empire and take color photographs of everything he saw. And he really photographed everything:
people, buildings, landscapes, railroads, bridges... thousands of color pictures! His idea was simple: record
three exposures of every scene onto a glass plate using a red, a green, and a blue filter. Never mind that there
was no way to print color photographs until much later, he envisioned special projectors to be installed in
"multimedia" classrooms all across Russia where the children would be able to learn about their vast country.
Alas, his plans never materialized: he left Russia in 1918, right after the revolution, never to return again.
Luckily, his RGB glass plate negatives, capturing the last years of the Russian Empire, survived and were
purchased in 1948 by the Library of Congress. The LoC has digitized the negatives and made them available
online. The glass plate negatives contain three color channel images.*


**Aligning the 3 channels of the Prokudin-Gorskii Photo Collection:**

For this assignment we have chosen one of his images, *monastery.jpg*.

Download this image, split the image
into three parts to extract the channels.

 The first channel is the blue channel, followed by the green channel,
and the red channel. Keep the blue channel fixed and align the green and red channels to the blue channel
in the following way:


(a) To compute the best alignment between two channels, "slide" one image over the other i.e. search over
a window of possible displacements say **[-10, 10]** pixels, score each one using an image matching metric
such as SSD, and take the displacement with the best score.


(b) What is your best SSD value and displacement vector for each channel?


(c) Once you find the best alignment between the channels, merge the 3 channels to get a coloured image.


(d) Display the coloured image.
"""

img2 = cv.imread('monastery.jpg',0)
#loads the image as grayscale
imht,imwdth = img2.shape[:2]
blue = img2[:int(imht/3)]
green = img2[int(imht/3):int(2*(imht/3)) + 1]
green= cv.copyMakeBorder(green,5,4,5,5,cv.BORDER_CONSTANT,None,value = 255)
red = img2[int(2*(imht/3)) + 1:imht]
red = cv.copyMakeBorder(red,5,5,5,5,cv.BORDER_CONSTANT,None,value = 255)
base_img = blue
#Taking subimages for the color channels
SSD = 0
h_img = 0
w_img = 0
#stores the best aligned displacement vector for the lowest ssd(Green channel)
for i in range(10):
    for j in range(10):
        slide = green[i:i+blue.shape[0],j:j+blue.shape[1]]
        temp_ssd = ssd(blue,slide)
        if SSD == 0 or SSD > temp_ssd:
            SSD = temp_ssd
            h_img = i
            w_img = j
print(f'''SSD for the Green channel: {SSD}
Displacement Vector of image: {[h_img,w_img]}
''')
img_green = green[h_img:h_img + blue.shape[0], w_img:w_img + blue.shape[1]]


SSD = 0
h_img = 0
w_img = 0
#stores the best aligned displacement vector for the lowest ssd(Red channel)

for i in range(10):
    for j in range(10):
        slide = red[i:i+blue.shape[0],j:j+blue.shape[1]]
        temp_ssd = ssd(blue,slide)
        if SSD == 0 or SSD > temp_ssd:
            SSD = temp_ssd
            h_img = i
            w_img = j
print(f'''SSD for the Red channel: {SSD}
Displacement Vector of image: {[h_img,w_img]}
''')
img_red = red[h_img:h_img + blue.shape[0], w_img:w_img + blue.shape[1]]

merged = cv.merge([base_img,img_green,img_red])
#Merged image for all three color channels is shown
cv2_imshow(merged)
cv.waitKey(0)
cv.destroyAllWindows()
cv.imwrite("Final_refined.jpg",merged)

